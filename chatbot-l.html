<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VANW | Chatbot AI VƒÉn H·ªçc</title>
    <link rel="icon" href="assets/logo.png" type="image/png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    <style>
        /* CSS loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            place-items: center;
            z-index: 9999;
            background-color: white;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }
        
        .loading-container {
            text-align: center;
        }
        
        .loading-container h1 {
            margin-bottom: 30px;
            font-weight: 300;
            letter-spacing: 2px;
            color: #ff6600;
        }
        
        .loading-screen svg {
            width: 200px;
            height: 200px;
        }
        
        .loading-screen .dot {
            transition: cx 0.5s cubic-bezier(0.3, 1.4, 0.4, 1),
                        cy 0.5s cubic-bezier(0.3, 1.4, 0.4, 1),
                        r 0.5s cubic-bezier(0.3, 1.4, 0.4, 1);
        }
        
        .loading-screen .dot {
            fill: #ff8441;
        }
        
        .loading-screen #gooey {
            transform-origin: 100px 100px;
            transition: transform 0.5s linear;
        }

        .loading-text {
            color: #ff6600;
            font-size: 1rem;
            font-weight: 600;
            margin-top: 20px;
            animation: pulse 1.5s infinite;
            text-align: center;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* CSS ch√≠nh */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .sidebar {
            width: 250px;
            background-color: #f8f9fa;
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .logo-link {
            display: flex;
            align-items: center;
            text-decoration: none;
        }
        .logo-icon {
            width: 32px;
            height: 32px;
        }
        .new-chat-btn {
            flex: 1;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #ed7839, #ff5722);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .new-chat-btn:hover {
            background: linear-gradient(135deg, #d46a2e, #e64a19);
        }
        .chat-history {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }
        .chat-item {
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .chat-item:hover {
            background-color: #e9ecef;
        }
        .chat-item.active {
            background-color: #e9ecef;
            border-left: 3px solid #ed7839;
        }
        .chat-title {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        .chat-date {
            font-size: 0.75rem;
            color: #666;
            opacity: 0.7;
        }
        .delete-chat-btn {
            background: none;
            border: none;
            color: #666;
            opacity: 0.7;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        .delete-chat-btn:hover {
            opacity: 1;
            background-color: rgba(255, 0, 0, 0.1);
            color: #ff4444;
        }
        .sidebar-footer {
            padding: 1rem;
            text-align: center;
            font-size: 0.8rem;
            color: #666;
            opacity: 0.7;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .welcome-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 2rem;
        }
        .welcome-logo {
            max-width: 400px;
            width: 100%;
            margin-bottom: 2rem;
        }
        .user-message {
            align-self: flex-end;
            background: linear-gradient(135deg, #ed7839, #ff5722);
            color: white;
            border-radius: 18px 18px 4px 18px;
            padding: 12px 16px;
            max-width: 70%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }
        .bot-message {
            align-self: flex-start;
            background-color: #ffffff;
            color: #333;
            border-radius: 18px 18px 18px 4px;
            padding: 12px 16px;
            max-width: 70%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        .quick-reply-message {
            align-self: flex-start;
            background-color: #ffffff;
            color: #333;
            border-radius: 18px 18px 18px 4px;
            padding: 12px 16px;
            max-width: 70%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            border: 2px solid #ff9800;
            position: relative;
            margin-bottom: 25px;
        }
        .quick-reply-label {
            position: absolute;
            bottom: -18px;
            left: 15px;
            background-color: #ff9800;
            color: white;
            font-size: 0.85rem;
            padding: 3px 10px;
            border-radius: 12px;
            font-weight: 600;
            white-space: nowrap;
            z-index: 1;
        }
        .quick-reply-label::after {
            content: '';
            position: absolute;
            top: -4px;
            left: 15px;
            width: 8px;
            height: 8px;
            background-color: #ff9800;
            transform: rotate(45deg);
        }
        .quick-reply-loading {
            display: inline-block;
            margin-left: 4px;
            color: white;
        }
        .typing-indicator {
            align-self: flex-start;
            background-color: #ffffff;
            color: #333;
            border-radius: 18px 18px 18px 4px;
            padding: 12px 16px;
            max-width: 70%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .typing-dots {
            display: flex;
            gap: 4px;
        }
        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ed7839;
            animation: typing 1.4s infinite ease-in-out;
        }
        .typing-dot:nth-child(1) {
            animation-delay: -0.32s;
        }
        .typing-dot:nth-child(2) {
            animation-delay: -0.16s;
        }
        @keyframes typing {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }
        .loading-dots {
            display: inline-block;
        }
        .loading-dots span {
            display: inline-block;
            animation: blink 1.4s infinite both;
            font-weight: bold;
            font-size: 1.2em;
        }
        .loading-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }
        .loading-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes blink {
            0%, 100% {
                opacity: 0.2;
            }
            50% {
                opacity: 1;
            }
        }
        .suggestions-bar {
            padding: 0.5rem 1rem;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }
        .suggestions-title {
            font-size: 0.9rem;
            color: #666;
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        .suggestions-container {
            display: flex;
            gap: 0.5rem;
            overflow-x: auto;
            padding-bottom: 0.5rem;
        }
        .suggestion-chip {
            background-color: #ffffff;
            color: #333;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 20px;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.3s ease;
        }
        .suggestion-chip:hover {
            background-color: #ed7839;
            color: white;
            border-color: #ed7839;
        }
        .input-area {
            padding: 1rem;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }
        .chat-form {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
        }
        .message-input {
            flex: 1;
            padding: 12px 16px;
            border-radius: 24px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background-color: #ffffff;
            color: #333;
            resize: none;
            min-height: 48px;
            max-height: 120px;
            transition: all 0.3s ease;
        }
        .message-input:focus {
            outline: none;
            border-color: #ed7839;
            box-shadow: 0 0 0 2px rgba(237, 120, 57, 0.2);
        }
        .send-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ed7839, #ff5722);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .send-button:hover {
            background: linear-gradient(135deg, #d46a2e, #e64a19);
        }
        .send-button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .markdown p {
            margin-bottom: 0.5rem;
        }
        .markdown ul, .markdown ol {
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
        }
        .markdown li {
            margin-bottom: 0.25rem;
        }
        .markdown code:not(pre code) {
            background-color: rgba(0, 0, 0, 0.1);
            padding: 0.1rem 0.3rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .markdown strong {
            font-weight: 600;
        }
        .markdown em {
            font-style: italic;
        }
        .markdown h1, .markdown h2, .markdown h3, .markdown h4 {
            font-weight: 600;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        .markdown h1 {
            font-size: 1.5rem;
        }
        .markdown h2 {
            font-size: 1.25rem;
        }
        .markdown h3 {
            font-size: 1.125rem;
        }
        .markdown h4 {
            font-size: 1rem;
        }
        .markdown blockquote {
            border-left: 4px solid #ed7839;
            padding-left: 1rem;
            margin: 0.5rem 0;
            color: #666;
        }
        .code-block {
            position: relative;
            margin: 0.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            background-color: #f8f9fa;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: rgba(0, 0, 0, 0.05);
            font-family: monospace;
            font-size: 0.8rem;
        }
        .copy-code-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }
        .copy-code-btn:hover {
            color: #ed7839;
        }
        pre {
            margin: 0 !important;
            padding: 1rem !important;
            overflow-x: auto;
        }
        .sidebar-toggle {
            position: fixed;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            z-index: 20;
            background-color: #ed7839;
            color: white;
            width: 30px;
            height: 50px;
            border-radius: 0 8px 8px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            display: none;
            border: none;
        }
        .sidebar-toggle:hover {
            background-color: #d46a2e;
        }
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                left: -250px;
                top: 0;
                height: 100%;
                z-index: 10;
                transition: left 0.3s ease;
            }
            .sidebar.active {
                left: 0;
            }
            .user-message, .bot-message, .quick-reply-message {
                max-width: 85%;
            }
            .quick-reply-label {
                font-size: 0.8rem;
                padding: 2px 8px;
                bottom: -16px;
            }
            .sidebar-toggle {
                display: flex;
            }
            .welcome-logo {
                max-width: 300px;
            }
            .loading-screen svg {
                width: 150px;
                height: 150px;
            }
        }
        @media (max-width: 480px) {
            .user-message, .bot-message, .quick-reply-message {
                max-width: 90%;
            }
            .quick-reply-label {
                font-size: 0.75rem;
                padding: 2px 6px;
                bottom: -14px;
            }
            .suggestions-container {
                flex-wrap: wrap;
            }
            .welcome-logo {
                max-width: 250px;
            }
            .loading-screen svg {
                width: 120px;
                height: 120px;
            }
            .loading-text {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-container">
            <svg viewBox="0 0 200 200">
                <defs>
                    <filter id="goo">
                        <feGaussianBlur in="SourceGraphic" stdDeviation="6" result="blur" />
                        <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0
                                    0 1 0 0 0
                                    0 0 1 0 0
                                    0 0 0 20 -10" result="goo" />
                        <feBlend in="SourceGraphic" in2="goo" />
                    </filter>
                </defs>
                <g id="gooey" filter="url(#goo)">
                    <circle class="dot" cx="100" cy="100" r="6" />
                </g>
            </svg>
            <div class="loading-text">ƒêang kh·ªüi t·∫°o h·ªá th·ªëng API...</div>
        </div>
    </div>

    <!-- Main App Container -->
    <div class="app-container" id="mainContent" style="display: none;">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="index.html" class="logo-link">
                    <img src="assets/logo.png" alt="VANW" class="logo-icon">
                </a>
                <button id="new-chat-btn" class="new-chat-btn">
                    <i class="fas fa-file-circle-plus"></i>
                    <span>ƒêo·∫°n nh·∫Øn m·ªõi</span>
                </button>
            </div>
            <div class="chat-history" id="chat-history"></div>
            <div class="sidebar-footer">
                <p>¬©2025 THPT Th·ª´a L∆∞u</p>
                <p>Ho√†ng Minh Tu·∫•n & Tr∆∞∆°ng Vi·∫øt Duy Ch∆∞∆°ng</p>
            </div>
        </div>
        <div class="chat-area">
            <div class="chat-messages" id="chat-messages">
                <div class="welcome-container">
                    <img src="assets/text.png" alt="VANW" class="welcome-logo">
                </div>
            </div>
            <div class="suggestions-bar" id="suggestions-bar">
                <div class="suggestions-title">G·ª£i √Ω c√¢u h·ªèi:</div>
                <div class="suggestions-container" id="suggestions-container">
                    <div class="suggestion-chip">Ph√¢n t√≠ch b√†i th∆° "ƒê√¢y th√¥n Vƒ© D·∫°"</div>
                    <div class="suggestion-chip">Gi·ªõi thi·ªáu v·ªÅ nh√† vƒÉn Nam Cao</div>
                    <div class="suggestion-chip">N·ªôi dung t√°c ph·∫©m "Ch√≠ Ph√®o"</div>
                    <div class="suggestion-chip">ƒê·∫∑c ƒëi·ªÉm th∆° H·ªì Xu√¢n H∆∞∆°ng</div>
                </div>
            </div>
            <div class="input-area">
                <form id="chat-form" class="chat-form">
                    <textarea 
                        id="message-input" 
                        class="message-input"
                        placeholder="Nh·∫≠p c√¢u h·ªèi v·ªÅ vƒÉn h·ªçc..."
                        rows="1"
                    ></textarea>
                    <button 
                        id="send-button" 
                        type="submit" 
                        class="send-button"
                    >
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </form>
            </div>
        </div>
    </div>
    <button class="sidebar-toggle" id="sidebarToggle">
        <i class="fas fa-chevron-right"></i>
    </button>
    
    <script type="importmap">
        {
            "imports": {
                "@google/generative-ai": "https://esm.run/@google/generative-ai"
            }
        }
    </script>
    <script type="module">
        import { GoogleGenerativeAI } from "@google/generative-ai";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "UHK6FEikvKhAhgmo0i8OZkGtW6Mq_ueJDySazIA",
            authDomain: "tkc-vanw.firebaseapp.com",
            projectId: "tkc-vanw",
            storageBucket: "tkc-vanw.firebasestorage.app",
            messagingSenderId: "862465503494",
            appId: "1:862465503494:web:8aec558b363988deec6e87",
            measurementId: "G-F23NN1KLW0"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // ============================
        // API PH√íNG TH·ª¶ H·ªÜ TH·ªêNG - ƒê√É S·ª¨A THEO Y√äU C·∫¶U
        // ============================
        class APIDefenseSystem {
            constructor() {
                // API key CH√çNH b·ªã ƒë·∫£o ng∆∞·ª£c
                this.reversedPrimaryApiKey = "cbRSGo7aT22YUIRKGY4db94W_uD1rUmkDySazIA";
                this.primaryModel = "gemini-2.5-flash";
                this.allApis = [];
                this.workingApis = [];
                this.currentApiIndex = -1;
                this.isInitialized = false;
                this.consolePrefix = "üîß [API Ph√≤ng Th·ªß]";
                this.currentWorkingApi = null; // API ƒëang ho·∫°t ƒë·ªông hi·ªán t·∫°i
            }

            // H√†m ƒë·∫£o ng∆∞·ª£c chu·ªói ƒë·ªÉ l·∫•y key ƒë√∫ng
            reverseApiKey(reversedKey) {
                if (!reversedKey || typeof reversedKey !== 'string') {
                    console.error(`${this.consolePrefix} API key kh√¥ng h·ª£p l·ªá:`, reversedKey);
                    return reversedKey;
                }
                return reversedKey.split('').reverse().join('');
            }

            async initialize() {
                console.log(`${this.consolePrefix} === B·∫ÆT ƒê·∫¶U KI·ªÇM TRA API THEO TH·ª® T·ª∞ ===`);
                console.log(`${this.consolePrefix} L∆∞u √Ω: T·∫•t c·∫£ API key ƒë·ªÅu ƒë∆∞·ª£c ƒë·∫£o ng∆∞·ª£c, h·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông ƒë·∫£o l·∫°i`);
                
                // Th√™m API ch√≠nh v√†o danh s√°ch (ƒë√£ ƒë·∫£o ng∆∞·ª£c)
                this.allApis.push({
                    reversedKey: this.reversedPrimaryApiKey,
                    apiKey: this.reverseApiKey(this.reversedPrimaryApiKey),
                    model: this.primaryModel,
                    isPrimary: true,
                    index: 0
                });
                
                // Load API d·ª± ph√≤ng t·ª´ file
                await this.loadBackupApis();
                
                // Test t·∫•t c·∫£ API theo th·ª© t·ª± - CH·ªà D·ª™NG KHI T√åM ƒê∆Ø·ª¢C API HO·∫†T ƒê·ªòNG
                await this.testApisSequentially();
                
                // Ki·ªÉm tra k·∫øt qu·∫£
                if (this.currentWorkingApi) {
                    console.log(`${this.consolePrefix} === ƒê√É T√åM TH·∫§Y API HO·∫†T ƒê·ªòNG: #${this.currentWorkingApi.index} ===`);
                    console.log(`${this.consolePrefix} S·ªë API ƒë√£ ki·ªÉm tra: ${this.checkedApisCount}`);
                    console.log(`${this.consolePrefix} S·ªë API c√≤n l·∫°i ch∆∞a ki·ªÉm tra: ${this.allApis.length - this.checkedApisCount}`);
                    this.isInitialized = true;
                    return this.currentWorkingApi;
                } else {
                    console.error(`${this.consolePrefix} === KH√îNG C√ì API N√ÄO HO·∫†T ƒê·ªòNG! ===`);
                    throw new Error("KH√îNG C√ì API N√ÄO HO·∫†T ƒê·ªòNG!");
                }
            }

            async loadBackupApis() {
                try {
                    console.log(`${this.consolePrefix} === ƒêANG T·∫¢I API D·ª∞ PH√íNG ===`);
                    
                    // Th·ª≠ c√°c ƒë∆∞·ªùng d·∫´n kh√°c nhau cho file apiphongthu.txt
                    const possiblePaths = [
                        'assets/apiphongthu.txt',
                    ];
                    
                    let response = null;
                    let usedPath = '';
                    
                    // Th·ª≠ t·ª´ng ƒë∆∞·ªùng d·∫´n
                    for (const path of possiblePaths) {
                        try {
                            console.log(`${this.consolePrefix} Th·ª≠ ƒë∆∞·ªùng d·∫´n: ${path}`);
                            response = await fetch(path);
                            if (response.ok) {
                                usedPath = path;
                                console.log(`${this.consolePrefix} ‚úì T√¨m th·∫•y file t·∫°i: ${path}`);
                                break;
                            }
                        } catch (e) {
                            console.log(`${this.consolePrefix} ‚úó Kh√¥ng t√¨m th·∫•y file t·∫°i: ${path}`);
                            continue;
                        }
                    }
                    
                    if (!response || !response.ok) {
                        console.log(`${this.consolePrefix} Kh√¥ng t√¨m th·∫•y file apiphongthu.txt, ch·ªâ d√πng API ch√≠nh`);
                        return false;
                    }
                    
                    const text = await response.text();
                    console.log(`${this.consolePrefix} N·ªôi dung file (truncated):`, text.substring(0, 200) + "...");
                    
                    // X·ª≠ l√Ω n·ªôi dung file
                    const lines = text.trim().split('\n').filter(line => line.trim() !== '');
                    
                    console.log(`${this.consolePrefix} S·ªë d√≤ng trong file: ${lines.length}`);
                    
                    // B·∫Øt ƒë·∫ßu index t·ª´ 1 v√¨ 0 l√† API ch√≠nh
                    let index = 1;
                    
                    // X·ª≠ l√Ω t·ª´ng c·∫∑p key-model
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        
                        if (!line) continue;
                        
                        // Ki·ªÉm tra n·∫øu d√≤ng n√†y c√≥ v·∫ª l√† API key
                        if (line.includes('AIza')) {
                            const reversedKey = line;
                            const model = (i + 1 < lines.length) ? lines[i + 1].trim() : this.primaryModel;
                            
                            console.log(`${this.consolePrefix}\n[API #${index}]`);
                            
                            // Th·ª≠ ƒë·∫£o ng∆∞·ª£c key ƒë·ªÉ xem c√≥ h·ª£p l·ªá kh√¥ng
                            const normalKey = this.reverseApiKey(reversedKey);
                            
                            // Ki·ªÉm tra n·∫øu key ƒë·∫£o l·∫°i c√≥ ch·ª©a "AIza" (d·∫•u hi·ªáu c·ªßa key h·ª£p l·ªá)
                            const isValidKey = normalKey.includes("AIza");
                            
                            const apiKey = isValidKey ? normalKey : reversedKey;
                            
                            this.allApis.push({
                                reversedKey: reversedKey,
                                apiKey: apiKey,
                                model: model,
                                isPrimary: false,
                                index: index
                            });
                            
                            console.log(`${this.consolePrefix} Model: ${model}`);
                            console.log(`${this.consolePrefix} Type: BACKUP`);
                            console.log(`${this.consolePrefix} Key h·ª£p l·ªá: ${isValidKey ? '‚úì' : '‚úó'}`);
                            
                            index++;
                            i++; // B·ªè qua d√≤ng model
                        } else if (line.toLowerCase().includes('gemini')) {
                            continue;
                        } else {
                            // Th·ª≠ xem c√≥ ph·∫£i l√† key ƒë·∫£o ng∆∞·ª£c kh√¥ng
                            const normalKey = this.reverseApiKey(line);
                            const isValidKey = normalKey.includes("AIza");
                            
                            if (isValidKey) {
                                const model = (i + 1 < lines.length) ? lines[i + 1].trim() : this.primaryModel;
                                
                                this.allApis.push({
                                    reversedKey: line,
                                    apiKey: normalKey,
                                    model: model,
                                    isPrimary: false,
                                    index: index
                                });
                                
                                console.log(`${this.consolePrefix} ‚úì Ph√°t hi·ªán key ƒë·∫£o ng∆∞·ª£c API #${index}`);
                                index++;
                                i++;
                            }
                        }
                    }
                    
                    console.log(`${this.consolePrefix}\n=== K·∫æT QU·∫¢ T·∫¢I API D·ª∞ PH√íNG ===`);
                    console.log(`${this.consolePrefix} ƒê√£ t·∫£i ${this.allApis.length - 1} API d·ª± ph√≤ng t·ª´ file`);
                    console.log(`${this.consolePrefix} File path: ${usedPath}`);
                    
                    return true;
                } catch (error) {
                    console.error(`${this.consolePrefix} L·ªói khi t·∫£i API d·ª± ph√≤ng:`, error);
                    return false;
                }
            }

            async testApiConnection(apiInfo) {
                try {
                    console.log(`${this.consolePrefix}\n[TEST API #${apiInfo.index}]`);
                    console.log(`${this.consolePrefix} Type: ${apiInfo.isPrimary ? 'PRIMARY' : 'BACKUP'}`);
                    
                    // Ki·ªÉm tra xem key c√≥ h·ª£p l·ªá kh√¥ng
                    if (!apiInfo.apiKey || apiInfo.apiKey.length < 20) {
                        console.log(`${this.consolePrefix} [API #${apiInfo.index}] ‚úó KEY KH√îNG H·ª¢P L·ªÜ (qu√° ng·∫Øn)`);
                        return null;
                    }
                    
                    // Ki·ªÉm tra xem key c√≥ ch·ª©a AIza kh√¥ng
                    if (!apiInfo.apiKey.includes("AIza")) {
                        console.log(`${this.consolePrefix} [API #${apiInfo.index}] ‚úó KEY KH√îNG H·ª¢P L·ªÜ (thi·∫øu 'AIza')`);
                        return null;
                    }
                    
                    const genAI = new GoogleGenerativeAI(apiInfo.apiKey);
                    const testModel = genAI.getGenerativeModel({ model: apiInfo.model || "gemini-2.5-flash" });
                    
                    // Test v·ªõi c√¢u h·ªèi ƒë∆°n gi·∫£n (timeout 5s)
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);
                    
                    try {
                        const testResult = await testModel.generateContent("Xin ch√†o");
                        const response = await testResult.response;
                        const text = response.text();
                        
                        clearTimeout(timeoutId);
                        
                        console.log(`${this.consolePrefix} [API #${apiInfo.index}] ‚úì HO·∫†T ƒê·ªòNG T·ªêT`);
                        
                        return {
                            ...apiInfo,
                            status: 'working'
                        };
                    } catch (timeoutError) {
                        console.log(`${this.consolePrefix} [API #${apiInfo.index}] ‚úó TIMEOUT`);
                        return null;
                    }
                } catch (error) {
                    console.log(`${this.consolePrefix} [API #${apiInfo.index}] ‚úó L·ªñI: ${error.message}`);
                    return null;
                }
            }

            async testApisSequentially() {
                this.workingApis = [];
                this.checkedApisCount = 0;
                
                console.log(`${this.consolePrefix}\n=== B·∫ÆT ƒê·∫¶U KI·ªÇM TRA ${this.allApis.length} API THEO TH·ª® T·ª∞ ===`);
                
                // Test tu·∫ßn t·ª± t·ª´ng API - D·ª™NG KHI T√åM ƒê∆Ø·ª¢C API HO·∫†T ƒê·ªòNG ƒê·∫¶U TI√äN
                for (let i = 0; i < this.allApis.length; i++) {
                    const apiInfo = this.allApis[i];
                    this.checkedApisCount++;
                    
                    console.log(`${this.consolePrefix} ƒêang ki·ªÉm tra API #${apiInfo.index} (${i+1}/${this.allApis.length})...`);
                    
                    const result = await this.testApiConnection(apiInfo);
                    
                    if (result) {
                        // T√¨m th·∫•y API ho·∫°t ƒë·ªông!
                        this.workingApis.push(result);
                        this.currentWorkingApi = result;
                        this.currentApiIndex = 0;
                        
                        console.log(`${this.consolePrefix}\nüéØ ƒê√É T√åM TH·∫§Y API HO·∫†T ƒê·ªòNG: #${apiInfo.index}`);
                        console.log(`${this.consolePrefix} D·ª´ng ki·ªÉm tra, kh√¥ng ki·ªÉm tra c√°c API c√≤n l·∫°i`);
                        
                        break; // D·ª™NG L·∫†I, KH√îNG KI·ªÇM TRA API TI·∫æP THEO
                    } else {
                        console.log(`${this.consolePrefix} API #${apiInfo.index} kh√¥ng ho·∫°t ƒë·ªông, ti·∫øp t·ª•c ki·ªÉm tra API ti·∫øp theo...`);
                    }
                    
                    // Delay nh·∫π gi·ªØa c√°c l·∫ßn test
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                console.log(`${this.consolePrefix}\n=== K·∫æT QU·∫¢ KI·ªÇM TRA ===`);
                console.log(`${this.consolePrefix} ƒê√£ ki·ªÉm tra: ${this.checkedApisCount}/${this.allApis.length} API`);
                console.log(`${this.consolePrefix} API ho·∫°t ƒë·ªông: ${this.workingApis.length}`);
                
                if (this.workingApis.length === 0) {
                    console.log(`${this.consolePrefix}\n‚ö†Ô∏è C·∫¢NH B√ÅO: Kh√¥ng c√≥ API n√†o ho·∫°t ƒë·ªông!`);
                }
                
                return this.workingApis;
            }

            getCurrentApi() {
                return this.currentWorkingApi;
            }

            async switchToNextApi() {
                if (this.workingApis.length <= 1) {
                    console.log(`${this.consolePrefix} Kh√¥ng c√≤n API d·ª± ph√≤ng n√†o trong danh s√°ch ho·∫°t ƒë·ªông!`);
                    
                    // Th·ª≠ ki·ªÉm tra l·∫°i c√°c API ch∆∞a ƒë∆∞·ª£c ki·ªÉm tra
                    console.log(`${this.consolePrefix} Ki·ªÉm tra l·∫°i c√°c API c√≤n l·∫°i...`);
                    
                    for (let i = this.checkedApisCount; i < this.allApis.length; i++) {
                        const apiInfo = this.allApis[i];
                        console.log(`${this.consolePrefix} Ki·ªÉm tra API #${apiInfo.index} (ƒë√£ b·ªè qua tr∆∞·ªõc ƒë√≥)...`);
                        
                        const result = await this.testApiConnection(apiInfo);
                        
                        if (result) {
                            this.workingApis.push(result);
                            this.currentWorkingApi = result;
                            this.currentApiIndex = this.workingApis.length - 1;
                            
                            console.log(`${this.consolePrefix} T√¨m th·∫•y API ho·∫°t ƒë·ªông m·ªõi: #${apiInfo.index}`);
                            return this.currentWorkingApi;
                        }
                    }
                    
                    console.log(`${this.consolePrefix} Kh√¥ng t√¨m th·∫•y API ho·∫°t ƒë·ªông m·ªõi n√†o!`);
                    return false;
                }
                
                // N·∫øu c√≥ nhi·ªÅu API ho·∫°t ƒë·ªông, chuy·ªÉn sang API ti·∫øp theo
                const nextIndex = (this.currentApiIndex + 1) % this.workingApis.length;
                this.currentApiIndex = nextIndex;
                this.currentWorkingApi = this.workingApis[nextIndex];
                
                console.log(`${this.consolePrefix} ƒê√£ chuy·ªÉn sang API ho·∫°t ƒë·ªông kh√°c: #${this.currentWorkingApi.index}`);
                return this.currentWorkingApi;
            }

            async tryAllApisForResponse(userMessage, conversationHistory) {
                console.log(`${this.consolePrefix}\n=== TH·ª¨ T·∫§T C·∫¢ API ƒê·ªÇ TR·∫¢ L·ªúI ===`);
                
                // N·∫øu kh√¥ng c√≥ API n√†o ho·∫°t ƒë·ªông
                if (!this.currentWorkingApi) {
                    console.log(`${this.consolePrefix} Kh√¥ng c√≥ API n√†o ho·∫°t ƒë·ªông!`);
                    return {
                        success: false,
                        error: "Kh√¥ng c√≥ API n√†o ho·∫°t ƒë·ªông"
                    };
                }
                
                // Th·ª≠ API hi·ªán t·∫°i tr∆∞·ªõc
                let lastError = null;
                
                for (let attempt = 0; attempt < 2; attempt++) {
                    try {
                        const genAI = new GoogleGenerativeAI(this.currentWorkingApi.apiKey);
                        const model = genAI.getGenerativeModel({ 
                            model: this.currentWorkingApi.model || "gemini-2.5-flash" 
                        });
                        
                        const chatSession = model.startChat({
                            history: conversationHistory,
                            generationConfig: {
                                maxOutputTokens: 1500,
                                temperature: 0.8,
                                topP: 0.1,
                                topK: 16,
                            }
                        });

                        const result = await chatSession.sendMessage(userMessage);
                        const response = await result.response;
                        const botReply = response.text();
                        
                        console.log(`${this.consolePrefix} ‚úì Th√†nh c√¥ng v·ªõi API #${this.currentWorkingApi.index} (l·∫ßn th·ª≠ ${attempt + 1})`);
                        
                        return {
                            success: true,
                            response: botReply,
                            apiInfo: this.currentWorkingApi
                        };
                    } catch (error) {
                        lastError = error;
                        console.log(`${this.consolePrefix} ‚úó API #${this.currentWorkingApi.index} l·ªói: ${error.message}`);
                        
                        // N·∫øu API hi·ªán t·∫°i l·ªói, th·ª≠ chuy·ªÉn sang API kh√°c
                        if (attempt === 0) {
                            console.log(`${this.consolePrefix} Th·ª≠ chuy·ªÉn sang API kh√°c...`);
                            const switched = await this.switchToNextApi();
                            
                            if (!switched) {
                                // Kh√¥ng c√≥ API n√†o kh√°c ho·∫°t ƒë·ªông
                                break;
                            }
                        }
                    }
                }
                
                // N·∫øu c·∫£ 2 l·∫ßn th·ª≠ ƒë·ªÅu th·∫•t b·∫°i
                console.log(`${this.consolePrefix} ‚úó T·∫•t c·∫£ API ƒë·ªÅu l·ªói!`);
                return {
                    success: false,
                    error: lastError ? lastError.message : "T·∫•t c·∫£ API ƒë·ªÅu kh√¥ng ho·∫°t ƒë·ªông"
                };
            }
        }

        // ============================
        // BI·∫æN TO√ÄN C·ª§C V√Ä H·ªÜ TH·ªêNG CH√çNH
        // ============================
        const chatMessages = document.getElementById('chat-messages');
        const chatForm = document.getElementById('chat-form');
        const messageInput = document.getElementById('message-input');
        const newChatBtn = document.getElementById('new-chat-btn');
        const chatHistory = document.getElementById('chat-history');
        const sendButton = document.getElementById('send-button');
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const suggestionsBar = document.getElementById('suggestions-bar');
        const suggestionsContainer = document.getElementById('suggestions-container');
        const loadingScreen = document.getElementById('loadingScreen');
        const mainContent = document.getElementById('mainContent');
        
        let chats = [];
        let currentChatId = null;
        let isSending = false;
        let isStopped = false;
        let isSidebarVisible = true;
        let quickReplyMessageId = null;
        let isFirstMessage = false;
        let apiDefenseSystem = null;
        let currentGenAI = null;
        let currentModel = null;

        // ============================
        // H√ÄM LOADING ANIMATION
        // ============================
        function startLoadingAnimation() {
            loadingScreen.style.display = 'grid';
            loadingScreen.style.opacity = '1';
            loadingScreen.style.visibility = 'visible';
            
            animateSpinner();
        }

        function hideLoadingScreen() {
            loadingScreen.style.opacity = '0';
            loadingScreen.style.visibility = 'hidden';
            mainContent.style.display = 'flex';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }

        function animateSpinner() {
            const svgGroup = document.querySelector("#gooey");
            if (!svgGroup) return;
            
            let centerDot = svgGroup.querySelector(".dot");

            const spacing = 25;

            function createDot(cx, cy, r) {
                const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                dot.setAttribute("cx", cx);
                dot.setAttribute("cy", cy);
                dot.setAttribute("r", 1);
                dot.classList.add("dot");
                svgGroup.appendChild(dot);
                return dot;
            }

            svgGroup.querySelectorAll(".dot").forEach((dot) => dot.remove());
            centerDot = createDot(100, 100, 6);

            const first4 = [
                { cx: 100, cy: 100 - spacing },
                { cx: 100, cy: 100 + spacing },
                { cx: 100 - spacing, cy: 100 },
                { cx: 100 + spacing, cy: 100 }
            ];

            const allDots = [];

            first4.forEach((pos) => {
                const dot = createDot(100, 100, 6);
                allDots.push(dot);
                const midX = (100 + pos.cx) / 2;
                const midY = (100 + pos.cy) / 2;
                setTimeout(() => {
                    dot.setAttribute("r", 8);
                    dot.setAttribute("cx", midX);
                    dot.setAttribute("cy", midY);
                }, 50);
                setTimeout(() => {
                    dot.setAttribute("r", 6);
                    dot.setAttribute("cx", pos.cx);
                    dot.setAttribute("cy", pos.cy);
                }, 500);
            });

            setTimeout(() => {
                const diagSpacing = spacing / Math.sqrt(2);
                const diagonal = [
                    { cx: 100 - diagSpacing, cy: 100 - diagSpacing },
                    { cx: 100 + diagSpacing, cy: 100 - diagSpacing },
                    { cx: 100 - diagSpacing, cy: 100 + diagSpacing },
                    { cx: 100 + diagSpacing, cy: 100 + diagSpacing }
                ];
                diagonal.forEach((pos) => {
                    const dot = createDot(100, 100, 6);
                    allDots.push(dot);
                    const midX = (100 + pos.cx) / 2;
                    const midY = (100 + pos.cy) / 2;
                    setTimeout(() => {
                        dot.setAttribute("r", 8);
                        dot.setAttribute("cx", midX);
                        dot.setAttribute("cy", midY);
                    }, 50);
                    setTimeout(() => {
                        dot.setAttribute("r", 6);
                        dot.setAttribute("cx", pos.cx);
                        dot.setAttribute("cy", pos.cy);
                    }, 500);
                });
            }, 1000);

            setTimeout(() => {
                svgGroup.style.transform = "rotate(360deg)";
            }, 2500);

            setTimeout(() => {
                svgGroup.style.transition = "transform 0.5s linear";
                svgGroup.style.transform = "rotate(0deg)";
                allDots.forEach((dot) => {
                    dot.setAttribute("cx", 100);
                    dot.setAttribute("cy", 100);
                    dot.setAttribute("r", 6);
                });
            }, 3000);
        }

        // ============================
        // H√ÄM KH·ªûI T·∫†O API PH√íNG TH·ª¶
        // ============================
        async function initializeAPIDefense() {
            try {
                console.log("üöÄ Kh·ªüi t·∫°o h·ªá th·ªëng API Ph√≤ng Th·ªß...");
                apiDefenseSystem = new APIDefenseSystem();
                
                // C·∫≠p nh·∫≠t loading text
                const loadingText = document.querySelector('.loading-text');
                loadingText.textContent = 'ƒêang ki·ªÉm tra c√°c API...';
                
                const apiInfo = await apiDefenseSystem.initialize();
                
                // C·∫≠p nh·∫≠t loading text khi ƒë√£ t√¨m th·∫•y API
                loadingText.textContent = 'ƒêang kh·ªüi ƒë·ªông chatbot...';
                
                // T·∫°o Gemini AI instance v·ªõi API ƒë√£ ch·ªçn
                currentGenAI = new GoogleGenerativeAI(apiInfo.apiKey);
                currentModel = currentGenAI.getGenerativeModel({ 
                    model: apiInfo.model || "gemini-2.5-flash" 
                });
                
                console.log(`‚úÖ H·ªá th·ªëng API Ph√≤ng Th·ªß ƒë√£ s·∫µn s√†ng`);
                console.log(`üìä ƒêang d√πng API: #${apiInfo.index}`);
                
                return true;
            } catch (error) {
                console.error("‚ùå L·ªói kh·ªüi t·∫°o API Ph√≤ng Th·ªß:", error);
                
                // C·∫≠p nh·∫≠t loading text khi c√≥ l·ªói
                const loadingText = document.querySelector('.loading-text');
                loadingText.textContent = 'ƒêang th·ª≠ API d·ª± ph√≤ng...';
                
                // Th·ª≠ d√πng API key c≈© t·ª´ code 1 nh∆∞ fallback
                try {
                    const fallbackApiKey = "AIzaSyDq_sSF2kgHzuDgYNpQef6EDrk8MsP0vlM";
                    currentGenAI = new GoogleGenerativeAI(fallbackApiKey);
                    currentModel = currentGenAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });
                    console.log("‚ö†Ô∏è ƒêang d√πng API fallback c≈©");
                    
                    // T·∫°o API info gi·∫£ cho fallback
                    apiDefenseSystem = {
                        currentWorkingApi: {
                            index: 'fallback',
                            apiKey: fallbackApiKey,
                            model: "gemini-2.5-flash-lite"
                        },
                        isInitialized: true,
                        getCurrentApi: () => apiDefenseSystem.currentWorkingApi,
                        switchToNextApi: async () => false,
                        tryAllApisForResponse: async (userMessage, conversationHistory) => {
                            try {
                                const genAI = new GoogleGenerativeAI(fallbackApiKey);
                                const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });
                                
                                const chatSession = model.startChat({
                                    history: conversationHistory,
                                    generationConfig: {
                                        maxOutputTokens: 1500,
                                        temperature: 0.8,
                                        topP: 0.1,
                                        topK: 16,
                                    }
                                });

                                const result = await chatSession.sendMessage(userMessage);
                                const response = await result.response;
                                const botReply = response.text();
                                
                                return {
                                    success: true,
                                    response: botReply,
                                    apiInfo: apiDefenseSystem.currentWorkingApi
                                };
                            } catch (error) {
                                return {
                                    success: false,
                                    error: error.message
                                };
                            }
                        }
                    };
                    
                    return true;
                } catch (fallbackError) {
                    console.error("‚ùå L·ªói c·∫£ v·ªõi API fallback:", fallbackError);
                    loadingText.textContent = 'Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông h·ªá th·ªëng API';
                    return false;
                }
            }
        }

        // ============================
        // H√ÄM G·ª¨I TIN NH·∫ÆN V·ªöI API PH√íNG TH·ª¶
        // ============================
        async function sendMessageWithAPIDefense(userMessage, currentChat) {
            if (!apiDefenseSystem || !apiDefenseSystem.isInitialized) {
                console.error("H·ªá th·ªëng API ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o!");
                return null;
            }

            try {
                // Th·ª≠ t·∫•t c·∫£ API ƒë·ªÉ tr·∫£ l·ªùi
                const result = await apiDefenseSystem.tryAllApisForResponse(
                    userMessage,
                    currentChat.messages.map(msg => ({
                        role: msg.role === "user" ? "user" : "model",
                        parts: [{ text: msg.content }]
                    }))
                );

                if (result.success) {
                    // C·∫≠p nh·∫≠t model hi·ªán t·∫°i n·∫øu API thay ƒë·ªïi
                    if (result.apiInfo) {
                        currentGenAI = new GoogleGenerativeAI(result.apiInfo.apiKey);
                        currentModel = currentGenAI.getGenerativeModel({ 
                            model: result.apiInfo.model || "gemini-2.5-flash" 
                        });
                        
                        console.log(`üîÑ ƒêang d√πng API #${result.apiInfo.index} ƒë·ªÉ tr·∫£ l·ªùi`);
                    }
                    
                    return result.response;
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error("L·ªói khi g·ª≠i tin nh·∫Øn v·ªõi API ph√≤ng th·ªß:", error);
                
                // Th·ª≠ ph∆∞∆°ng ph√°p c≈© n·∫øu h·ªá th·ªëng API ph√≤ng th·ªß th·∫•t b·∫°i
                if (currentModel) {
                    try {
                        const chatSession = currentModel.startChat({
                            history: currentChat.messages.map(msg => ({
                                role: msg.role === "user" ? "user" : "model",
                                parts: [{ text: msg.content }]
                            })),
                            generationConfig: {
                                maxOutputTokens: 1500,
                                temperature: 0.8,
                                topP: 0.1,
                                topK: 16,
                            }
                        });

                        const result = await chatSession.sendMessage(userMessage);
                        const response = await result.response;
                        return response.text();
                    } catch (innerError) {
                        console.error("L·ªói c·∫£ v·ªõi ph∆∞∆°ng ph√°p c≈©:", innerError);
                        return null;
                    }
                }
                
                return null;
            }
        }

        // ============================
        // C√ÅC H√ÄM CH·ª®C NƒÇNG CH√çNH
        // ============================
        const literaryKeywords = [
            "vƒÉn h·ªçc", "t√°c ph·∫©m", "nh√† vƒÉn", "th∆°", "truy·ªán", "t√°c gi·∫£", "ch√†o", "l√† ai", 
            "ti·ªÉu thuy·∫øt", "ch√†o", "b·ªüi ai", "c·∫£m h·ª©ng", "vi·∫øt", "ch·ªØ", "t·ª´", "c√¢u", 
            "t√≥m t·∫Øt", "tr√¨nh b·∫ßy", "t·∫°o", "ho√†n thi·ªán", "vƒÉn", "tr√≠ch", "ngu·ªìn g·ªëc", 
            "t·ª´", "vƒÉn","th∆°","truy·ªán","ca dao","t·ª•c ng·ªØ","nh√¢n v·∫≠t","t√°c gi·∫£",
            "t√°c ph·∫©m","th·ªùi k·ª≥","vƒÉn h·ªçc","th∆° ca","truy·ªán ng·∫Øn","ti·ªÉu thuy·∫øt",
            "k·ªãch","vƒÉn xu√¥i","l·ª•c b√°t","t·ª± do","ƒê∆∞·ªùng lu·∫≠t","th∆° m·ªõi","th∆° c·ªï",
            "hi·ªán ƒë·∫°i","tr·ªØ t√¨nh","tr√†o ph√∫ng","ch·ªØ H√°n","ch·ªØ N√¥m","ch·ªØ Qu·ªëc ng·ªØ",
            "d√¢n gian","cung ƒë√¨nh","c√°ch m·∫°ng","kh√°ng chi·∫øn","h·∫≠u chi·∫øn","ƒë∆∞∆°ng ƒë·∫°i",
            "n∆∞·ªõc ngo√†i","thi ph√°p","ng√¥n ng·ªØ","h√¨nh t∆∞·ª£ng","b√∫t ph√°p","ch·ªß ƒë·ªÅ",
            "t∆∞ t∆∞·ªüng","ngh·ªá thu·∫≠t","phong c√°ch","v·∫ßn ƒë·∫°o","thi·ªÅn","t√¨nh y√™u",
            "qu√™ h∆∞∆°ng","chi·∫øn tranh","h√≤a b√¨nh","l·ªãch s·ª≠","vƒÉn h√≥a","x√£ h·ªôi",
            "nh√¢n ƒë·∫°o","hi·ªán th·ª±c","l√£ng m·∫°n","bi k·ªãch","h√†i k·ªãch","anh h√πng",
            "ph·∫£n di·ªán","t√¢m l√Ω","tri·∫øt l√Ω","t∆∞·ª£ng tr∆∞ng","si√™u th·ª±c","c·ªï ƒëi·ªÉn",
            "hi·ªán ƒë·∫°i","h·∫≠u hi·ªán ƒë·∫°i","trung ƒë·∫°i","c·∫≠n ƒë·∫°i","ph·ª•c h∆∞ng","khai s√°ng",
            "l√£ng m·∫°n","t·ª± s·ª±","tr·ªØ t√¨nh","t·∫£ th·ª±c","·∫©n d·ª•","ho√°n d·ª•","nh√¢n h√≥a",
            "so s√°nh","ƒëi·ªáp ng·ªØ","·∫©n √Ω","t·ª© th∆°","v·∫ßn ƒëi·ªáu","nh·ªãp ƒëi·ªáu","c√¢u th∆°",
            "ƒëo·∫°n th∆°","b√†i th∆°","t·∫≠p th∆°","tuy·ªÉn t·∫≠p","vƒÉn b·∫£n","b·∫£n d·ªãch",
            "nguy√™n t√°c","t√°c ph·∫©m kinh ƒëi·ªÉn","t√°c ph·∫©m ti√™u bi·ªÉu","t√°c ph·∫©m n·ªïi ti·∫øng",
            "t√°c ph·∫©m vƒÉn h·ªçc","t√°c ph·∫©m ngh·ªá thu·∫≠t","t√°c ph·∫©m vƒÉn h√≥a",
            "t√°c ph·∫©m l·ªãch s·ª≠","t√°c ph·∫©m tri·∫øt h·ªçc","t√°c ph·∫©m t√¥n gi√°o",
            "t√°c ph·∫©m ch√≠nh tr·ªã","t√°c ph·∫©m x√£ h·ªôi","t√°c ph·∫©m nh√¢n vƒÉn",
            "t√°c ph·∫©m khoa h·ªçc","t√°c ph·∫©m gi√°o d·ª•c","t√°c ph·∫©m vƒÉn minh"
        ];

        function isLiteraryQuestion(question) {
            const lowerQuestion = question.toLowerCase();
            return literaryKeywords.some(keyword => lowerQuestion.includes(keyword.toLowerCase()));
        }

        function generateSuggestions(messages) {
            const userMessages = messages.filter(msg => msg.role === "user");
            if (userMessages.length === 0) {
                return [
                    "Ph√¢n t√≠ch b√†i th∆° 'ƒê√¢y th√¥n Vƒ© D·∫°' c·ªßa H√†n M·∫∑c T·ª≠",
                    "K·ªÉ t√™n c√°c t√°c ph·∫©m ti√™u bi·ªÉu c·ªßa Nam Cao",
                    "Gi·ªõi thi·ªáu v·ªÅ phong tr√†o Th∆° m·ªõi 1932-1945",
                    "Ph√¢n t√≠ch nh√¢n v·∫≠t Ch√≠ Ph√®o trong t√°c ph·∫©m c√πng t√™n"
                ];
            }
            const lastMessage = userMessages[userMessages.length - 1].content;
            if (lastMessage.includes("ph√¢n t√≠ch")) {
                return [
                    "B·∫°n c√≥ th·ªÉ ph√¢n t√≠ch s√¢u h∆°n v·ªÅ ngh·ªá thu·∫≠t trong t√°c ph·∫©m n√†y kh√¥ng?",
                    "T√°c gi·∫£ s·ª≠ d·ª•ng nh·ªØng bi·ªán ph√°p tu t·ª´ n√†o?",
                    "√ù nghƒ©a nhan ƒë·ªÅ c·ªßa t√°c ph·∫©m l√† g√¨?"
                ];
            } else if (lastMessage.includes("t√°c gi·∫£")) {
                return [
                    `C√°c t√°c ph·∫©m kh√°c c·ªßa t√°c gi·∫£ n√†y l√† g√¨?`,
                    "Phong c√°ch s√°ng t√°c c·ªßa t√°c gi·∫£ n√†y",
                    "·∫¢nh h∆∞·ªüng c·ªßa t√°c gi·∫£ n√†y ƒë·∫øn vƒÉn h·ªçc Vi·ªát Nam"
                ];
            } else if (lastMessage.includes("th∆°")) {
                return [
                    "Ph√¢n t√≠ch h√¨nh ·∫£nh trong b√†i th∆°",
                    "B·ªë c·ª•c c·ªßa b√†i th∆° n√†y nh∆∞ th·∫ø n√†o?",
                    "Ho√†n c·∫£nh s√°ng t√°c b√†i th∆° n√†y"
                ];
            }
            return [
                "B·∫°n c√≥ th·ªÉ gi·∫£i th√≠ch r√µ h∆°n v·ªÅ ƒëi·ªÅu n√†y kh√¥ng?",
                "C√≥ t√°c ph·∫©m n√†o t∆∞∆°ng t·ª± nh∆∞ v·∫≠y kh√¥ng?",
                "√ù nghƒ©a s√¢u xa c·ªßa v·∫•n ƒë·ªÅ n√†y l√† g√¨?"
            ];
        }

        async function initApp() {
            console.log("üöÄ Kh·ªüi ƒë·ªông VANW Chatbot...");
            
            // Hi·ªÉn th·ªã loading screen
            startLoadingAnimation();
            
            // Kh·ªüi t·∫°o API ph√≤ng th·ªß
            const apiInitSuccess = await initializeAPIDefense();
            
            if (!apiInitSuccess) {
                addMessageToUI("assistant", 
                    "‚ö†Ô∏è **C·∫£nh b√°o h·ªá th·ªëng:**\n\n" +
                    "H·ªá th·ªëng g·∫∑p s·ª± c·ªë khi kh·ªüi t·∫°o API. M·ªôt s·ªë t√≠nh nƒÉng c√≥ th·ªÉ b·ªã h·∫°n ch·∫ø.\n" +
                    "Vui l√≤ng refresh trang n·∫øu v·∫•n ƒë·ªÅ ti·∫øp di·ªÖn."
                );
            }
            
            // ·∫®n loading screen v√† hi·ªÉn th·ªã n·ªôi dung ch√≠nh
            hideLoadingScreen();
            
            // Ti·∫øp t·ª•c kh·ªüi t·∫°o app nh∆∞ b√¨nh th∆∞·ªùng
            loadChats();
            setupEventListeners();
            setupTextareaAutoResize();
            setupSuggestionChips();
            
            if (chats.length === 0) {
                createNewChat();
            } else {
                loadChat(chats[0].id);
            }
            
            console.log("‚úÖ VANW Chatbot ƒë√£ s·∫µn s√†ng!");
        }

        function setupSuggestionChips() {
            const chips = suggestionsContainer.querySelectorAll('.suggestion-chip');
            chips.forEach(chip => {
                chip.addEventListener('click', function() {
                    messageInput.value = this.textContent;
                    messageInput.focus();
                    autoResizeTextarea();
                });
            });
        }

        function setupEventListeners() {
            chatForm.addEventListener('submit', handleSubmit);
            messageInput.addEventListener('input', autoResizeTextarea);
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (messageInput.value.trim() !== '') {
                        chatForm.dispatchEvent(new Event('submit'));
                    }
                }
            });
            newChatBtn.addEventListener('click', createNewChat);
        }

        function setupTextareaAutoResize() {
            messageInput.style.height = 'auto';
            const newHeight = Math.min(messageInput.scrollHeight, 120);
            messageInput.style.height = `${newHeight}px`;
        }

        function autoResizeTextarea() {
            messageInput.style.height = 'auto';
            const newHeight = Math.min(messageInput.scrollHeight, 120);
            messageInput.style.height = `${newHeight}px`;
        }

        async function checkQuickReply(userMessage) {
            try {
                const normalizedMessage = userMessage.toLowerCase().trim();
                const snapshot = await db.collection('first_messages')
                    .where('normalizedQuestion', '==', normalizedMessage)
                    .limit(1)
                    .get();
                if (!snapshot.empty) {
                    const doc = snapshot.docs[0];
                    const data = doc.data();
                    await doc.ref.update({
                        usageCount: firebase.firestore.FieldValue.increment(1),
                        lastUsed: new Date().toISOString()
                    });
                    return data.answer;
                }
                return null;
            } catch (error) {
                console.error("L·ªói khi ki·ªÉm tra ph·∫£n h·ªìi nhanh:", error);
                return null;
            }
        }

        async function saveFirstMessageToFirestore(userMessage, aiResponse) {
            try {
                const normalizedMessage = userMessage.toLowerCase().trim();
                await db.collection('first_messages').add({
                    question: userMessage,
                    normalizedQuestion: normalizedMessage,
                    answer: aiResponse,
                    createdAt: new Date().toISOString(),
                    usageCount: 1,
                    lastUsed: new Date().toISOString()
                });
                console.log("ƒê√£ l∆∞u tin nh·∫Øn ƒë·∫ßu ti√™n v√†o Firestore");
            } catch (error) {
                console.error("L·ªói khi l∆∞u v√†o Firestore:", error);
            }
        }

        async function handleSubmit(e) {
            e.preventDefault();
            const userMessage = messageInput.value.trim();
            if (!userMessage || isSending) return;
            
            if (!isLiteraryQuestion(userMessage)) {
                addMessageToUI("assistant", "Xin l·ªói, t√¥i ch·ªâ tr·∫£ l·ªùi chuy√™n v·ªÅ c√°c c√¢u h·ªèi li√™n quan ƒë·∫øn vƒÉn h·ªçc, b·∫°n c√≥ c√¢u h·ªèi n√†o li√™n quan ƒë·∫øn vƒÉn h·ªçc m√† mu·ªën h·ªèi t√¥i kh√¥ng?");
                messageInput.value = "";
                autoResizeTextarea();
                return;
            }

            if (!currentChatId) {
                createNewChat();
                return;
            }

            const currentChat = chats.find(chat => chat.id === currentChatId);
            if (!currentChat) {
                console.error("Kh√¥ng t√¨m th·∫•y cu·ªôc tr√≤ chuy·ªán hi·ªán t·∫°i!");
                return;
            }

            isSending = true;
            addMessageToUI("user", userMessage);
            sendButton.innerHTML = '<div class="loading-spinner"></div>';
            sendButton.disabled = true;

            const greetings = ["ch√†o", "hello", "hi", "xin ch√†o"];
            if (greetings.some(greet => userMessage.toLowerCase().includes(greet))) {
                const greetingResponse = "Xin ch√†o, t√¥i l√† AI vƒÉn h·ªçc VANW ƒë∆∞·ª£c t·∫°o ra b·ªüi Ho√†ng Minh Tu·∫•n v√† Tr∆∞∆°ng Vi·∫øt Duy Ch∆∞∆°ng ƒë·∫øn t·ª´ tr∆∞·ªùng THPT Th·ª´a L∆∞u. T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n v·ªÅ vƒÉn h·ªçc ngay b√¢y gi·ªù?";
                displayTypingMessage(greetingResponse, () => {
                    if (!isStopped) {
                        currentChat.messages.push({ 
                            role: "assistant", 
                            content: greetingResponse,
                            timestamp: new Date().toISOString()
                        });
                        saveChats();
                        updateSuggestions(currentChat.messages);
                    }
                });
                messageInput.value = "";
                autoResizeTextarea();
                isSending = false;
                resetSendButton();
                return;
            }

            isFirstMessage = currentChat.messages.length === 0;
            const userMessageObj = { 
                role: "user", 
                content: userMessage,
                timestamp: new Date().toISOString()
            };
            currentChat.messages.push(userMessageObj);
            saveChats();
            updateChatTitle(currentChat);
            messageInput.value = "";
            autoResizeTextarea();
            isStopped = false;

            try {
                let quickReplyContent = null;
                let hasQuickReply = false;
                
                if (isFirstMessage) {
                    quickReplyContent = await checkQuickReply(userMessage);
                    if (quickReplyContent) {
                        hasQuickReply = true;
                        showQuickReply(quickReplyContent);
                    }
                }

                let botReply;
                
                // S·ª≠ d·ª•ng h·ªá th·ªëng API ph√≤ng th·ªß ƒë·ªÉ g·ª≠i tin nh·∫Øn
                if (apiDefenseSystem && apiDefenseSystem.isInitialized) {
                    botReply = await sendMessageWithAPIDefense(userMessage, currentChat);
                } else {
                    // Fallback: d√πng ph∆∞∆°ng ph√°p c≈©
                    if (currentModel) {
                        const chatSession = currentModel.startChat({
                            history: currentChat.messages.map(msg => ({
                                role: msg.role === "user" ? "user" : "model",
                                parts: [{ text: msg.content }]
                            })),
                            generationConfig: {
                                maxOutputTokens: 1500,
                                temperature: 0.8,
                                topP: 0.1,
                                topK: 16,
                            }
                        });

                        const result = await chatSession.sendMessage(userMessage);
                        const response = await result.response;
                        botReply = response.text();
                    } else {
                        throw new Error("Kh√¥ng c√≥ model n√†o ƒë∆∞·ª£c kh·ªüi t·∫°o");
                    }
                }

                if (!botReply) {
                    throw new Error("Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ AI");
                }

                const limitedReply = limitWords(botReply, 250);
                
                if (hasQuickReply) {
                    removeQuickReply();
                    addMessageToUI("assistant", limitedReply);
                    currentChat.messages.push({ 
                        role: "assistant", 
                        content: limitedReply,
                        timestamp: new Date().toISOString()
                    });
                } else {
                    displayTypingMessage(limitedReply, () => {
                        if (!isStopped) {
                            currentChat.messages.push({ 
                                role: "assistant", 
                                content: limitedReply,
                                timestamp: new Date().toISOString()
                            });
                            saveChats();
                            if (isFirstMessage) {
                                saveFirstMessageToFirestore(userMessage, limitedReply);
                            }
                            updateSuggestions(currentChat.messages);
                        }
                    });
                }
            } catch (error) {
                console.error("L·ªói: ", error);
                
                // Th√¥ng b√°o l·ªói th√¢n thi·ªán
                let errorMessage = "Xin l·ªói, ƒë√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi v·ªõi AI. ";
                
                if (error.message.includes("quota") || error.message.includes("limit")) {
                    errorMessage += "C√≥ th·ªÉ ƒë√£ h·∫øt l∆∞·ª£t truy c·∫≠p API. ";
                }
                
                errorMessage += "Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c ƒë·∫∑t c√¢u h·ªèi kh√°c!";
                
                if (hasQuickReply) {
                    removeQuickReply();
                }
                
                addMessageToUI("assistant", errorMessage);
            } finally {
                isSending = false;
                resetSendButton();
                scrollToBottom();
            }
        }

        function showQuickReply(content) {
            const welcomeContainer = document.querySelector('.welcome-container');
            if (welcomeContainer) {
                welcomeContainer.remove();
            }
            const messageDiv = document.createElement('div');
            messageDiv.className = 'quick-reply-message';
            messageDiv.id = 'quick-reply-' + Date.now();
            quickReplyMessageId = messageDiv.id;
            const formattedContent = formatMessage(content);
            messageDiv.innerHTML = `
                <div class="markdown">${formattedContent}</div>
                <div class="quick-reply-label">
                    Ph·∫£n h·ªìi nhanh ‚Ä¢ ƒêang x·ª≠ l√Ω t·ª± ki·ªÉm ch·ª©ng c√°c c√¢u tr·∫£ l·ªùi
                    <span class="loading-dots">
                        <span>.</span><span>.</span><span>.</span>
                    </span>
                </div>
            `;
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function removeQuickReply() {
            if (quickReplyMessageId) {
                const quickReplyElement = document.getElementById(quickReplyMessageId);
                if (quickReplyElement) {
                    quickReplyElement.remove();
                }
                quickReplyMessageId = null;
            }
        }

        function limitWords(text, maxWords) {
            const words = text.split(' ');
            if (words.length <= maxWords) {
                return text;
            }
            const limitedWords = words.slice(0, maxWords);
            return limitedWords.join(' ') + '...';
        }

        function resetSendButton() {
            sendButton.innerHTML = '<i class="fas fa-paper-plane"></i>';
            sendButton.disabled = false;
        }

        function updateSuggestions(messages) {
            const suggestions = generateSuggestions(messages);
            suggestionsContainer.innerHTML = '';
            if (suggestions.length > 0) {
                suggestions.forEach(suggestion => {
                    const chip = document.createElement('div');
                    chip.className = 'suggestion-chip';
                    chip.textContent = suggestion;
                    chip.addEventListener('click', () => {
                        messageInput.value = suggestion;
                        messageInput.focus();
                        autoResizeTextarea();
                    });
                    suggestionsContainer.appendChild(chip);
                });
                suggestionsBar.style.display = 'block';
            } else {
                suggestionsBar.style.display = 'none';
            }
        }

        function displayTypingMessage(content, callback) {
            const welcomeContainer = document.querySelector('.welcome-container');
            if (welcomeContainer) {
                welcomeContainer.remove();
            }
            const messageDiv = document.createElement('div');
            messageDiv.className = 'typing-indicator';
            messageDiv.innerHTML = `
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
                <span>AI ƒëang suy nghƒ©, vui l√≤ng ƒë·ª£i gi√¢y l√°t</span>
            `;
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
            setTimeout(() => {
                messageDiv.remove();
                addMessageToUI("assistant", content);
                if (callback) callback();
            }, 1500);
        }

        function addMessageToUI(role, content) {
            const welcomeContainer = document.querySelector('.welcome-container');
            if (welcomeContainer && role === "user") {
                welcomeContainer.remove();
            }
            const messageDiv = document.createElement('div');
            messageDiv.className = role === 'user' ? 'user-message' : 'bot-message';
            const formattedContent = formatMessage(content);
            messageDiv.innerHTML = `<div class="markdown">${formattedContent}</div>`;
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function formatMessage(content) {
            if (!content) return '';
            let formatted = content.replace(/```([\w]*)\n([\s\S]*?)```/g, (match, lang, code) => {
                const langDisplay = lang ? lang : 'text';
                return `<div class="code-block">
                    <div class="code-header">
                        <span>${langDisplay}</span>
                        <button class="copy-code-btn" onclick="copyToClipboard(this)" data-code="${encodeURIComponent(code.trim())}">
                            <i class="fas fa-copy"></i> Copy code
                        </button>
                    </div>
                    <pre><code class="language-${lang || 'text'}">${escapeHtml(code.trim())}</code></pre>
                </div>`;
            });
            formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
            formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
            formatted = formatted.split('\n\n').map(paragraph => {
                if (paragraph.trim().startsWith('<') && paragraph.trim().endsWith('>')) {
                    return paragraph;
                }
                return `<p>${paragraph}</p>`;
            }).join('');
            formatted = formatted.replace(/\n(?![<])/g, '<br>');
            return formatted;
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        function scrollToBottom() {
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 100);
        }

        function createNewChat() {
            const newChat = {
                id: Date.now().toString(),
                title: 'ƒêo·∫°n nh·∫Øn m·ªõi',
                messages: [],
                createdAt: new Date().toISOString()
            };
            chats.unshift(newChat);
            saveChats();
            renderChatHistory();
            loadChat(newChat.id);
            messageInput.focus();
            suggestionsBar.style.display = 'block';
            const welcomeContainer = document.querySelector('.welcome-container');
            if (!welcomeContainer) {
                chatMessages.innerHTML = '';
                const welcomeDiv = document.createElement('div');
                welcomeDiv.className = 'welcome-container';
                welcomeDiv.innerHTML = '<img src="assets/text.png" alt="VANW" class="welcome-logo">';
                chatMessages.appendChild(welcomeDiv);
            }
        }

        function loadChat(chatId) {
            currentChatId = chatId;
            document.querySelectorAll('.chat-item').forEach(item => {
                if (item.dataset.id === chatId) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
            chatMessages.innerHTML = '';
            const currentChat = chats.find(chat => chat.id === chatId);
            if (!currentChat) return;
            if (currentChat.messages.length > 0) {
                currentChat.messages.forEach(message => {
                    addMessageToUI(message.role, message.content);
                });
                updateSuggestions(currentChat.messages);
            } else {
                const welcomeDiv = document.createElement('div');
                welcomeDiv.className = 'welcome-container';
                welcomeDiv.innerHTML = '<img src="assets/text.png" alt="VANW" class="welcome-logo">';
                chatMessages.appendChild(welcomeDiv);
                suggestionsBar.style.display = 'block';
            }
            scrollToBottom();
        }

        function deleteChat(chatId, event) {
            event.stopPropagation();
            chats = chats.filter(chat => chat.id !== chatId);
            saveChats();
            renderChatHistory();
            if (chatId === currentChatId) {
                if (chats.length > 0) {
                    loadChat(chats[0].id);
                } else {
                    createNewChat();
                }
            }
        }

        function updateChatTitle(chat) {
            if (!chat || !chat.messages || chat.messages.length === 0) {
                chat.title = "ƒêo·∫°n nh·∫Øn m·ªõi";
                saveChats();
                renderChatHistory();
                return;
            }
            const firstUserMessage = chat.messages.find(msg => msg.role === "user");
            if (firstUserMessage) {
                let title = firstUserMessage.content.substring(0, 40);
                if (firstUserMessage.content.length > 40) {
                    title += "...";
                }
                chat.title = title || "ƒêo·∫°n nh·∫Øn m·ªõi";
            } else {
                chat.title = "ƒêo·∫°n nh·∫Øn m·ªõi";
            }
            saveChats();
            renderChatHistory();
        }

        function renderChatHistory() {
            chatHistory.innerHTML = '';
            if (chats.length === 0) {
                chatHistory.innerHTML = `
                    <div class="text-center p-4" style="color: #666; opacity: 0.7;">
                        Ch∆∞a c√≥ ƒëo·∫°n nh·∫Øn n√†o
                    </div>
                `;
                return;
            }
            chats.forEach(chat => {
                const chatItem = document.createElement('div');
                chatItem.className = `chat-item ${chat.id === currentChatId ? 'active' : ''}`;
                chatItem.dataset.id = chat.id;
                const chatDate = new Date(chat.createdAt || chat.id);
                const formattedDate = chatDate.toLocaleDateString('vi-VN', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                });
                chatItem.innerHTML = `
                    <div class="chat-title">${chat.title || 'ƒêo·∫°n nh·∫Øn m·ªõi'}</div>
                    <div class="chat-date">${formattedDate}</div>
                    <button class="delete-chat-btn">
                        <i class="fas fa-trash"></i>
                    </button>
                `;
                chatItem.addEventListener('click', (e) => {
                    if (!e.target.closest('.delete-chat-btn')) {
                        loadChat(chat.id);
                    }
                });
                const deleteBtn = chatItem.querySelector('.delete-chat-btn');
                deleteBtn.addEventListener('click', (e) => {
                    deleteChat(chat.id, e);
                });
                chatHistory.appendChild(chatItem);
            });
        }

        function loadChats() {
            const storedChats = localStorage.getItem('vanw-chats');
            if (storedChats) {
                const now = Date.now();
                const THIRTY_DAYS = 30 * 24 * 60 * 60 * 1000;
                chats = JSON.parse(storedChats)
                    .filter(chat => now - new Date(chat.createdAt || chat.id).getTime() < THIRTY_DAYS)
                    .sort((a, b) => new Date(b.createdAt || b.id) - new Date(a.createdAt || a.id));
                saveChats();
                renderChatHistory();
            }
        }

        function saveChats() {
            const now = Date.now();
            const THIRTY_DAYS = 30 * 24 * 60 * 60 * 1000;
            chats = chats.filter(chat => {
                const chatTime = new Date(chat.createdAt || chat.id).getTime();
                return now - chatTime < THIRTY_DAYS;
            });
            localStorage.setItem('vanw-chats', JSON.stringify(chats));
        }

        function copyToClipboard(button) {
            const code = decodeURIComponent(button.getAttribute('data-code'));
            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.innerHTML;
                button.innerHTML = '<i class="fas fa-check"></i> ƒê√£ sao ch√©p!';
                setTimeout(() => {
                    button.innerHTML = originalText;
                }, 2000);
            });
        }

        // ============================
        // X·ª¨ L√ù SIDEBAR TOGGLE
        // ============================
        sidebarToggle.addEventListener('click', function() {
            isSidebarVisible = !isSidebarVisible;
            toggleSidebar();
        });

        function toggleSidebar() {
            if (isSidebarVisible) {
                sidebar.style.left = '0';
                sidebarToggle.innerHTML = '<i class="fas fa-chevron-left"></i>';
            } else {
                sidebar.style.left = '-250px';
                sidebarToggle.innerHTML = '<i class="fas fa-chevron-right"></i>';
            }
        }

        // ============================
        // KH·ªûI CH·∫†Y ·ª®NG D·ª§NG
        // ============================
        window.addEventListener("beforeunload", () => {
            chats = chats.filter(chat => chat.messages.length > 0);
            saveChats();
        });

        document.addEventListener('DOMContentLoaded', initApp);
        window.copyToClipboard = copyToClipboard;
    </script>
</body>
</html>
